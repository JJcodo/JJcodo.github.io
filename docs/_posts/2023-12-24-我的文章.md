---
layout: post
title: 大页相关笔记
date: 2024-01-01 08:00:17 
last_modified_at: 2024-01-01 08:00:18
tags: [Linux内核]
author: Daniel
math: true
toc: true
description: 记录一些大页相关的知识
---
# 大页相关笔记



### 1、arm64架构为什么支持64K大页

​         支持大页的原因是，arm64架构支持Contiguous bit特性，该特性主要是针对 TLB entry 的优化（连续的 16 个 PTE/PMB，若其上的 PFN 也是连续的，cont bit 会将其使用的 16 个 TLB entry 优化仅占一个 TLB entry）

![image-20240103233114131](https://raw.githubusercontent.com/JJcodo/Pictures/main/image-20240103233114131.png)

上表的含义是

1、当base page size大小是4K时，Contiguous bit支持连续16个PTE仅占用一个

2、当base page size大小是16K时，Contiguous bit支持连续32个PTE仅占用一个

3、当base page size大小是64K时，Contiguous bit支持连续8个PTE仅占用一个



参考文章

https://www.infoq.cn/article/qpq8tugsdmbkrae7wfe8

https://patchwork.kernel.org/project/linux-arm-kernel/patch/1442340117-3964-1-git-send-email-dwoods@ezchip.com/

https://www.kernel.org/doc/html/v5.9/arm64/hugetlbpage.html

https://lore.kernel.org/all/1442430186-9083-1-git-send-email-jeremy.linton@arm.com/

```c
efi_status_t check_platform_features(void)
{
	u64 tg;

	/*
	 * If we have 48 bits of VA space for TTBR0 mappings, we can map the
	 * UEFI runtime regions 1:1 and so calling SetVirtualAddressMap() is
	 * unnecessary.
	 */
	if (VA_BITS_MIN >= 48 && !system_needs_vamap())
		efi_novamap = true;

	/* UEFI mandates support for 4 KB granularity, no need to check */
	if (IS_ENABLED(CONFIG_ARM64_4K_PAGES))
		return EFI_SUCCESS;

	tg = (read_cpuid(ID_AA64MMFR0_EL1) >> ID_AA64MMFR0_EL1_TGRAN_SHIFT) & 0xf;
	if (tg < ID_AA64MMFR0_EL1_TGRAN_SUPPORTED_MIN || tg > ID_AA64MMFR0_EL1_TGRAN_SUPPORTED_MAX) {
		if (IS_ENABLED(CONFIG_ARM64_64K_PAGES))
			efi_err("This 64 KB granular kernel is not supported by your CPU\n");
		else
			efi_err("This 16 KB granular kernel is not supported by your CPU\n");
		return EFI_UNSUPPORTED;
	}
	return EFI_SUCCESS;
}
```

参考文档

https://blog.csdn.net/tiantao2012/article/details/55251264
