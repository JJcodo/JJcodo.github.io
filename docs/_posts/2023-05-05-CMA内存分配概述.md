---
layout: post
title: CMA内存分配概述
date: 2023-05-05 23:31:31 
last_modified_at: 2023-05-05 23:31:31 
tags: []
author: Daniel
toc: true
description:关于CMA内存分配的一些概述
---
# CMA内存分配

今天发现Linux6.2主干上关于CMA内存分配的实现相对于5.x版本有了很大的变化，所以再次分析总结一下。首先第一个问题什么是CMA内存？

CMA （Contiguous Memory Allocator） 是Linux内核中用于分配大块连续物理内存的内存分配器。

CMA的内存知识主要分为3部分，第一个部分是初始化，第二个部分是分配内存，第三个部分是释放内存。

dma_contiguous_reserve 函数负责初始化。

```c
// limit 一个物理地址限制值，表示内核应当在此物理地址之下预留 DMA 连续内存。
// dma内存预留需要配置三个参数，分别是size_cmdline、 base_cmdline、limit_cmdline
// 分别表示预留内存的大小、从哪里开始预留内存、预留限制的最大物理地址
void __init dma_contiguous_reserve(phys_addr_t limit)
dma_contiguous_default_area
dma_contiguous_reserve_area
```

dma_alloc_from_contiguous函数负责分配内存。

dma_free_from_contiguous函数负责释放内存。



CMA内核分配通过cma_alloc函数来实现。

```c
struct page *cma_alloc(struct cma *cma, unsigned long count,unsigned int align, bool no_warn) {
    // 
    cma_bitmap_aligned_mask（）；
     
}
```



cma_bitmap_aligned_mask函数

```c
// cma_bitmap_aligned_mask函数是用于计算位图掩码的函数，这个掩码可以确保在连续内存分配（CMA）过程中分配的内存块满足对齐要求。那么什么是对齐？order_per_bit的含义是用于每个位所对应的连续页数
static unsigned long cma_bitmap_aligned_mask(const struct cma *cma,
					     unsigned int align_order)
{
	if (align_order <= cma->order_per_bit)
		return 0;
	return (1UL << (align_order - cma->order_per_bit)) - 1;
}
```

cma_bitmap_aligned_offset函数

```c
// cma_bitmap_aligned_offset函数用于计算与指定对齐要求相匹配的位图偏移量
static unsigned long cma_bitmap_aligned_offset(const struct cma *cma,
					       unsigned int align_order)
{
	return (cma->base_pfn & ((1UL << align_order) - 1))
		>> cma->order_per_bit;
}
```

