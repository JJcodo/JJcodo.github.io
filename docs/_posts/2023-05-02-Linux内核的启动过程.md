---
layout: post
title: ARM64-Linux内核启动流程 
date: 2023-05-02 18:22:19 
last_modified_at: 2023-05-02 18:22:19 
tags: [阅读笔记, 内核初始化]
author: Daniel
toc: true
description: start_kernel函数的阅读笔记
---
# ARM64-Linux内核启动流程

## 引言

最近在看start_kernel函数的时候产生了一些问题，促使我去探索start_kernel之前内核的执行

start_kernel位于init/main.c文件当中，其定义如下所示

```c
/*
*  其中asmlinkage 、__visible、__no_sanitize_address和__init都是用来修饰函数的，其目的是为了更好的控制编译器，使得程序得到优化
*/
asmlinkage __visible void __init __no_sanitize_address start_kernel(void) {
    // 用于在init_task栈末尾设置一个特殊的“魔数”（magic number），这个魔数在内核中被用来检测栈溢出
    set_task_stack_end_magic(&init_task);
    // .................................
    // 初始化cgroup子系统，首先初始化root节点
    // 之后遍历cgroup_subsys数组，并用cgroup_subsys_name依次对齐进行name和id的初始化
    // 如果需要被设置了early_init标志，还需要进行子系统的初始化
    cgroup_init_early（）;
    
}
```

问题1：在cgroup_init_early函数中，发现`cgroup_subsys_name`是用来初始化`ss->name`的，并且在`cgroup_init_early`函数中还需要对这个成员检查

```c
 WARN(!ss->css_alloc || !ss->css_free || ss->name || ss->id,......）；
 WARN(strlen(cgroup_subsys_name[i]) > MAX_CGROUP_TYPE_NAMELEN,......）；
```

我觉得`start_kernel`的时间已经够早了,他们是什么时候初始化的，在执行`statr_kernel`前内核又干了什么？

## 正文

### 内核启动的入口

内核启动的入口位于`arch/arm64/kernel/head.S`文件中的`__HEAD`宏，这个宏的上方指明此处是内核启动的入口。

同时，需要关闭MMU，关闭D-cache， 同时x0寄存器的值需要指向FDT设备树的地址。

```shell
MMU = off, D-cache = off, I-cache = on or off,
x0 = physical address to the FDT blob.
```

#### 汇编代码

```assembly
__HEAD
// 跳转到primary_entry, 也就是内核的启动的地址，启动内核
b	primary_entry


```

primary_entry代码段

在这个代码段中，跳转执行了许多代码段，一个个分析

```
SYM_CODE_START(primary_entry)
	bl	preserve_boot_args
	bl	init_kernel_el			// w0=cpu_boot_mode
	mov	x20, x0
	bl	create_idmap
#if VA_BITS > 48
	mrs_s	x0, SYS_ID_AA64MMFR2_EL1
	tst	x0, #0xf << ID_AA64MMFR2_EL1_VARange_SHIFT
	mov	x0, #VA_BITS
	mov	x25, #VA_BITS_MIN
	csel	x25, x25, x0, eq
	mov	x0, x25
#endif
	bl	__cpu_setup			// initialise processor
	b	__primary_switch
SYM_CODE_END(primary_entry)	
```

preserve_boot_args代码段

```
SYM_CODE_START_LOCAL(preserve_boot_args)
	mov	x21, x0				// x21=FDT

	adr_l	x0, boot_args			// record the contents of
	stp	x21, x1, [x0]			// x0 .. x3 at kernel entry
	stp	x2, x3, [x0, #16]

	dmb	sy				// needed before dc ivac with
						// MMU off

	add	x1, x0, #0x20			// 4 x 8 bytes
	b	dcache_inval_poc		// tail call
SYM_CODE_END(preserve_boot_args)
```



### 参考文章

这篇文章使用反编译的方式找到了内核启动的函数入口，过程概述如下

- ```shell
  # 执行readeif 命令，查看程序入口地址为0xffff000008080000
  readelf -h vmlinux
  #E ntry point address:               0xffff000008080000
  ```

- ```shell
  # 使用aarch64-linux-gnu-objdump 反编译vmlinux 
  aarch64-linux-gnu-objdump -dxh vmlinux > vmlinux.s
  # 根据入口地址0xffff000008080000可查询到对应的代码段.head.text
  # 之后根据代码段查询到_HEAD宏
  #define __HEAD		.section	".head.text","ax"
  # 在arch/arm64/kernel/head.S文件中找到__HEAD宏的使用
  # 注释中解释这里是内核启动的入口（Kernel startup entry point）
  ```

[Linux内核启动流程-基于ARM64-By micro虾米](https://mshrimp.github.io/2020/04/19/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EARM64/)



> 在Linux内核启动过程中，很多具体的细节取决于特定的硬件架构。然而，大致的过程是相似的。这里以常见的x86_64架构为例，解释一下Linux内核的启动过程：
>
> 1. BIOS/UEFI：计算机上电后，首先执行的是BIOS或者UEFI固件。它的任务是执行POST（Power-On Self Test），初始化CPU和硬件设备，然后加载第一段可执行代码，这通常是引导加载器。
>
> 2. 引导加载器（Bootloader）：Bootloader（例如GRUB）的任务是加载内核映像和初始RAM磁盘（initrd）到内存中，然后跳转执行内核代码。引导加载器会设置一些初步的环境，例如切换到保护模式（对于x86架构）。
>
> 3. 内核启动：内核的入口点是`arch/x86/boot/header.S`中的`_start`，这是实模式下的入口点。这段代码的任务是切换到长模式（64位模式），然后跳转到`arch/x86/kernel/head64.c`中的`secondary_startup_64`。
>
> 4. 内核初始化：`secondary_startup_64`会继续初始化硬件和内核，然后调用`start_kernel`（在`init/main.c`中）。`start_kernel`是内核初始化的主函数，它会依次调用一系列的初始化函数。
>
> 5. 进程启动：最后，内核会启动第一个用户空间进程，这通常是`/sbin/init`或者由内核参数`init=`指定的其他程序。这个进程会继续启动其他的用户空间进程。
