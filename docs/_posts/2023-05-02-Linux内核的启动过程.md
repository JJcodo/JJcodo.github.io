---
layout: post
title: ARM64-Linux内核启动流程 
date: 2023-05-02 18:22:19 
last_modified_at: 2023-05-02 18:22:19 
tags: [阅读笔记, 内核初始化]
author: Daniel
toc: true
description: start_kernel函数的阅读笔记
---
# ARM64-Linux内核启动流程

## 引言

这些汇编真JB难，看不懂想干什么

最近在看start_kernel函数的时候产生了一些问题，促使我去探索start_kernel之前内核的执行

start_kernel位于init/main.c文件当中，其定义如下所示

```c
/*
*  其中asmlinkage 、__visible、__no_sanitize_address和__init都是用来修饰函数的，其目的是为了更好的控制编译器，使得程序得到优化
*/
asmlinkage __visible void __init __no_sanitize_address start_kernel(void) {
    // 用于在init_task栈末尾设置一个特殊的“魔数”（magic number），这个魔数在内核中被用来检测栈溢出
    set_task_stack_end_magic(&init_task);
    // .................................
    // 初始化cgroup子系统，首先初始化root节点
    // 之后遍历cgroup_subsys数组，并用cgroup_subsys_name依次对齐进行name和id的初始化
    // 如果需要被设置了early_init标志，还需要进行子系统的初始化
    cgroup_init_early();
    
}
```

问题1：在cgroup_init_early函数中，发现`cgroup_subsys_name`是用来初始化`ss->name`的，并且在`cgroup_init_early`函数中还需要对这个成员检查

```c
 WARN(!ss->css_alloc || !ss->css_free || ss->name || ss->id,......);
 WARN(strlen(cgroup_subsys_name[i]) > MAX_CGROUP_TYPE_NAMELEN,......);
```

我觉得`start_kernel`的时间已经够早了,他们是什么时候初始化的，在执行`statr_kernel`前内核又干了什么？

## 正文

### 内核启动的入口

内核启动的入口位于`arch/arm64/kernel/head.S`文件中的`__HEAD`宏，这个宏的上方指明此处是内核启动的入口。

同时，需要关闭MMU，关闭D-cache， 同时x0寄存器的值需要指向FDT设备树的地址。

```shell
MMU = off, D-cache = off, I-cache = on or off,
x0 = physical address to the FDT blob.
```

#### 汇编代码

```c
__HEAD
// 跳转到primary_entry, 也就是内核的启动的地址，启动内核
b	primary_entry


```

primary_entry代码段

在这个代码段中，跳转执行了许多代码段，一个个分析

```c
SYM_CODE_START(primary_entry)
	bl	preserve_boot_args
	bl	init_kernel_el			// w0=cpu_boot_mode
	// 保存init_kernel_el的返回值到x20寄存器中
	mov	x20, x0
	bl	create_idmap
#if VA_BITS > 48
	mrs_s	x0, SYS_ID_AA64MMFR2_EL1
	tst	x0, #0xf << ID_AA64MMFR2_EL1_VARange_SHIFT
	mov	x0, #VA_BITS
	mov	x25, #VA_BITS_MIN
	csel	x25, x25, x0, eq
	mov	x0, x25
#endif
	bl	__cpu_setup			// initialise processor
	b	__primary_switch
SYM_CODE_END(primary_entry)	
```

preserve_boot_args代码段

用于将启动参数保存到内存中，这些参数 FDT 地址和寄存器 `x0`、`x1`、`x2` 和 `x3` 中的值，它们会被按顺序存储到一个预定义的内存区域中，这个内存区域的地址由boot_args符号确定。

```c
SYM_CODE_START_LOCAL(preserve_boot_args)
	mov	x21, x0				// x21=FDT

	adr_l	x0, boot_args			// record the contents of
	stp	x21, x1, [x0]			// x0 .. x3 at kernel entry
	stp	x2, x3, [x0, #16]

	dmb	sy				// needed before dc ivac with
						// MMU off

	add	x1, x0, #0x20			// 4 x 8 bytes
	b	dcache_inval_poc		// tail call
SYM_CODE_END(preserve_boot_args)
```

init_kernel_el 代码段

这个代码段的作用是初始化操作系统内核，并将控制权转移到内核的主函数中。查看当前的异常级别是不是CurrentEL_EL2，如果不是，则需要执行init_el1初始化流程，其主要任务是禁用 MMU、设置 PSTATE_EL1 寄存器的初始值、设置返回地址、进入 EL1 模式等。如果是，则跳转到init_el2初始化流程，其主要任务是设置虚拟化扩展（Virtualization Extensions，简称 VHE）相关的标志、初始化 EL2 模式的状态、设置 Hypervisor Stub 的向量表地址、进入 EL2 模式等。



```c
SYM_FUNC_START(init_kernel_el)
	mrs	x0, CurrentEL
	cmp	x0, #CurrentEL_EL2
	b.eq	init_el2

SYM_INNER_LABEL(init_el1, SYM_L_LOCAL)
	// 系统控制寄存器sctlr_el1被设置为INIT_SCTLR_EL1_MMU_OFF，表示要关闭MMU
	mov_q	x0, INIT_SCTLR_EL1_MMU_OFF
	msr	sctlr_el1, x0
	isb
	// 将当前处理器状态的副本保存到 spsr_el1 寄存器中
	// 程序执行返回时，处理器状态会自动恢复到 SPSR_EL1 寄存器中保存的状态
	mov_q	x0, INIT_PSTATE_EL1
	msr	spsr_el1, x0
	// 保存当前程序返回地址Lr到elr_el1寄存器中
	msr	elr_el1, lr
	// 保存 #BOOT_CPU_MODE_EL1的值到w0寄存器中
	mov	w0, #BOOT_CPU_MODE_EL1
	eret

SYM_INNER_LABEL(init_el2, SYM_L_LOCAL)
	mov_q	x0, HCR_HOST_NVHE_FLAGS
	msr	hcr_el2, x0
	isb

	init_el2_state

	/* Hypervisor stub */
	adr_l	x0, __hyp_stub_vectors
	msr	vbar_el2, x0
	isb

	mov_q	x1, INIT_SCTLR_EL1_MMU_OFF

	/*
	 * Fruity CPUs seem to have HCR_EL2.E2H set to RES1,
	 * making it impossible to start in nVHE mode. Is that
	 * compliant with the architecture? Absolutely not!
	 */
	mrs	x0, hcr_el2
	and	x0, x0, #HCR_E2H
	cbz	x0, 1f

	/* Set a sane SCTLR_EL1, the VHE way */
	msr_s	SYS_SCTLR_EL12, x1
	mov	x2, #BOOT_CPU_FLAG_E2H
	b	2f

1:
	msr	sctlr_el1, x1
	mov	x2, xzr
2:
	msr	elr_el2, lr
	mov	w0, #BOOT_CPU_MODE_EL2
	orr	x0, x0, x2
	eret
SYM_FUNC_END(init_kernel_el)

```

create_idmap代码段

create_idmap是一段用于创建线性映射的代码，这个过程首先是初始化页表，之后计算地址范围，并根据计算得到的地址范围田中页表项，当页表项被填充完毕，映射关系就可以启用，最后则需要通过刷新TLB来使映射关系立即生效。

```c

SYM_FUNC_START_LOCAL(create_idmap)
    // 记录代码段返回地址
	mov	x28, lr
    // VA_BITS is the bumber of virtual address bits used 
#if (VA_BITS < 48)
    // PGDIR_SHIFT is the size if the page directory table
    // so the IDMAP_PGD_ORDER is number of  page directory tables.
#define IDMAP_PGD_ORDER	(VA_BITS - PGDIR_SHIFT)
    // PAGE_SHIFT is the size of the page table and also is represents to page size
#define EXTRA_SHIFT	(PGDIR_SHIFT + PAGE_SHIFT - 3)
#if VA_BITS != EXTRA_SHIFT
#error "Mismatch between VA_BITS and page size/number of translation levels"
#endif
#else
#define IDMAP_PGD_ORDER	(PHYS_MASK_SHIFT - PGDIR_SHIFT)
#define EXTRA_SHIFT
#endif
	adrp	x0, init_idmap_pg_dir
	adrp	x3, _text
	adrp	x6, _end + MAX_FDT_SIZE + SWAPPER_BLOCK_SIZE
	mov	x7, SWAPPER_RX_MMUFLAGS
	map_memory x0, x1, x3, x6, x7, x3, IDMAP_PGD_ORDER, x10, x11, x12, x13, x14, EXTRA_SHIFT
	adrp	x1, _text
	adrp	x2, init_pg_dir
	adrp	x3, init_pg_end
	bic	x4, x2, #SWAPPER_BLOCK_SIZE - 1
	mov	x5, SWAPPER_RW_MMUFLAGS
	mov	x6, #SWAPPER_BLOCK_SHIFT
	bl	remap_region
	adrp	x1, _text
	adrp	x22, _end + SWAPPER_BLOCK_SIZE
	bic	x2, x22, #SWAPPER_BLOCK_SIZE - 1
	bfi	x22, x21, #0, #SWAPPER_BLOCK_SHIFT		// remapped FDT address
	add	x3, x2, #MAX_FDT_SIZE + SWAPPER_BLOCK_SIZE
	bic	x4, x21, #SWAPPER_BLOCK_SIZE - 1
	mov	x5, SWAPPER_RW_MMUFLAGS
	mov	x6, #SWAPPER_BLOCK_SHIFT
	bl	remap_region
	dmb	sy
	adrp	x0, init_idmap_pg_dir
	adrp	x1, init_idmap_pg_end
	bl	dcache_inval_poc
	ret	x28
SYM_FUNC_END(create_idmap)

```



#### 异常级别

> 异常级别是 Armv8-A 架构中的一个概念，用于描述当前处理器运行的特权级别，包括 EL0、EL1、EL2 和 EL3 四个级别。不同的异常级别拥有不同的特权级别和访问权限，用于实现多任务、虚拟化等复杂操作系统功能。
>
> 在 Armv8-A 架构中，`CurrentEL` 寄存器的编号为12（或者使用别名 `CurrentEL`）。该寄存器是一个只读寄存器，用于记录当前运行的异常级别。`CurrentEL` 寄存器的取值范围为0~3，分别对应 EL0、EL1、EL2 和 EL3 四个异常级别。
>
> 可以使用 `mrs` 指令将 `CurrentEL` 寄存器中的值移动到一个通用寄存器中
>
> ```c
> # 将系统寄存器CurrentEL移动到通用寄存器x0
> mrs x0, CurrentEL
> ```
>
> 这个指令将当前异常级别的值读取到寄存器 x0 中，然后可以根据该值进行后续操作，例如判断当前程序的特权级别，或者根据不同的特权级别进行不同的操作。
>
> - EL0：最低特权级别，用于用户态应用程序的执行。
> - EL1：普通的操作系统级别，用于内核态程序的执行。
> - EL2：虚拟化扩展级别，用于虚拟机监控器的执行。
> - EL3：安全监控级别，用于安全的启动和运行时环境的执行。

#### 代码段返回值

> 在 ARM64 汇编语言中，w0 和 x0 都是 64 位通用寄存器，它们是同一个寄存器的两个不同访问方式。
>
> 在返回值的情况下，ARM64 调用惯例规定，32 位整数类型的返回值存储在 w0 中，64 位整数类型的返回值存储在 x0 中。

### 参考文章

这篇文章使用反编译的方式找到了内核启动的函数入口，过程概述如下

- ```shell
  # 执行readeif 命令，查看程序入口地址为0xffff000008080000
  readelf -h vmlinux
  #E ntry point address:               0xffff000008080000
  ```

- ```shell
  # 使用aarch64-linux-gnu-objdump 反编译vmlinux 
  aarch64-linux-gnu-objdump -dxh vmlinux > vmlinux.s
  # 根据入口地址0xffff000008080000可查询到对应的代码段.head.text
  # 之后根据代码段查询到_HEAD宏
  #define __HEAD		.section	".head.text","ax"
  # 在arch/arm64/kernel/head.S文件中找到__HEAD宏的使用
  # 注释中解释这里是内核启动的入口（Kernel startup entry point）
  ```

[Linux内核启动流程-基于ARM64-By micro虾米](https://mshrimp.github.io/2020/04/19/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E5%9F%BA%E4%BA%8EARM64/)



> 在Linux内核启动过程中，很多具体的细节取决于特定的硬件架构。然而，大致的过程是相似的。这里以常见的x86_64架构为例，解释一下Linux内核的启动过程：
>
> 1. BIOS/UEFI：计算机上电后，首先执行的是BIOS或者UEFI固件。它的任务是执行POST（Power-On Self Test），初始化CPU和硬件设备，然后加载第一段可执行代码，这通常是引导加载器。
>
> 2. 引导加载器（Bootloader）：Bootloader（例如GRUB）的任务是加载内核映像和初始RAM磁盘（initrd）到内存中，然后跳转执行内核代码。引导加载器会设置一些初步的环境，例如切换到保护模式（对于x86架构）。
>
> 3. 内核启动：内核的入口点是`arch/x86/boot/header.S`中的`_start`，这是实模式下的入口点。这段代码的任务是切换到长模式（64位模式），然后跳转到`arch/x86/kernel/head64.c`中的`secondary_startup_64`。
>
> 4. 内核初始化：`secondary_startup_64`会继续初始化硬件和内核，然后调用`start_kernel`（在`init/main.c`中）。`start_kernel`是内核初始化的主函数，它会依次调用一系列的初始化函数。
>
> 5. 进程启动：最后，内核会启动第一个用户空间进程，这通常是`/sbin/init`或者由内核参数`init=`指定的其他程序。这个进程会继续启动其他的用户空间进程。
