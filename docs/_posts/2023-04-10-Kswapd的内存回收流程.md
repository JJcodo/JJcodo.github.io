---
layout: post
title: kswapd的简介
date: 2023-4-15 23:18 +0800
last_modified_at: 2023-4-15 22:08:25 +0800
tags: [Linux内核, 内存回收, 笔记]
toc:  true
---

## kswapd的简介

​		kswapd是内核中负责回收的内核线程，在系统内存不足的时候会被唤醒执行内存回收.

### kswapd的初始化

```c
/*
*  kswapd的初始化
*/
static int __init kswapd_init(void)
{
	int nid;

	swap_setup(); //set the page_cluster
	for_each_node_state(nid, N_MEMORY)
 		kswapd_run(nid);
	return 0;
}
module_init(kswapd_init)
void kswapd_run(int nid)
{
	pg_data_t *pgdat = NODE_DATA(nid);
	pgdat_kswapd_lock(pgdat);
	if (!pgdat->kswapd) {
		pgdat->kswapd = kthread_run(kswapd, pgdat, "kswapd%d", nid);
		if (IS_ERR(pgdat->kswapd)) {
			/* failure at boot is fatal */
			BUG_ON(system_state < SYSTEM_RUNNING);
			pr_err("Failed to start kswapd on node %d\n", nid);
			pgdat->kswapd = NULL;
		}
	}
	pgdat_kswapd_unlock(pgdat);
}
```

​		kswapd的初始化由`kswapd_init`函数来完成，`kswapd_init`会由module_init宏来进行初始化。在这个函数中，他会遍历节点，为每个节点创建一个kswapd进程，然后唤醒执行，并让pgdat->kswapd保存kswapd的进程描述符。`static int kswapd(void *p)`是kswapd进程的执行函数。`kswapd_try_to_sleep` 负责kswapd函数的休眠工作。在`kswapd`函数中，alloc_order表示要回收的内存数量，在`balance_pgdat`执行真正的内存回收流程。

```c
#define PF_KSWAPD		0x00020000	/* I am kswapd */
#define PF_MEMALLOC		0x00000800	/* Allocating memory */
static int kswapd(void *p)
{
	unsigned int alloc_order, reclaim_order;
	unsigned int highest_zoneidx = MAX_NR_ZONES - 1;
	pg_data_t *pgdat = (pg_data_t *)p;
	struct task_struct *tsk = current;
	const struct cpumask *cpumask = cpumask_of_node(pgdat->node_id);

	if (!cpumask_empty(cpumask))
		set_cpus_allowed_ptr(tsk, cpumask);
    // 标记当前进程是kswapd
	tsk->flags |= PF_MEMALLOC | PF_KSWAPD;
	set_freezable();

	WRITE_ONCE(pgdat->kswapd_order, 0);
	WRITE_ONCE(pgdat->kswapd_highest_zoneidx, MAX_NR_ZONES);
	atomic_set(&pgdat->nr_writeback_throttled, 0);
	for ( ; ; ) {
		bool ret;

		alloc_order = reclaim_order = READ_ONCE(pgdat->kswapd_order);
		highest_zoneidx = kswapd_highest_zoneidx(pgdat,
							highest_zoneidx);

kswapd_try_sleep:
		kswapd_try_to_sleep(pgdat, alloc_order, reclaim_order,
					highest_zoneidx);
		
		/* Read the new order and highest_zoneidx */
		alloc_order = READ_ONCE(pgdat->kswapd_order);
		highest_zoneidx = kswapd_highest_zoneidx(pgdat,
							highest_zoneidx);
		WRITE_ONCE(pgdat->kswapd_order, 0);
		WRITE_ONCE(pgdat->kswapd_highest_zoneidx, MAX_NR_ZONES);

		ret = try_to_freeze();
		if (kthread_should_stop())
			break;
		if (ret)
			continue;
		trace_mm_vmscan_kswapd_wake(pgdat->node_id, highest_zoneidx,
						alloc_order);
		reclaim_order = balance_pgdat(pgdat, alloc_order,
						highest_zoneidx);
		if (reclaim_order < alloc_order)
			goto kswapd_try_sleep;
	}
	tsk->flags &= ~(PF_MEMALLOC | PF_KSWAPD);
    return 0;
}

```

### kswapd内存回收流程

​		kswapd内存回收流程的入口函数是`balance_pgdat`，这里出现了一个重要的结构体`struct scan_control`，他用来记录回收过程中重要的参数，其中nr_to_reclaim记录了要回收的内存页、。从名字来看，kswapd的目的是让当前节点处于一种平衡状态中。

#### kswapd回收的简单流程

​		首先记录一下kswapd的简单回收流程，通过这个流程我们可以看到整个回收的主要过程，首先是便利memcg回收内存，在每个memcg的过程中，都会先回收LRU的内存，之后在回收slab的内存。

```c
mem_cgroup_lruvec
balance_pgdat
    kswapd_age_node
    	shrink_active_list
    		
    kswapd_shrink_node
    	//要回收的内存页
    	sc->nr_to_reclaim += max(high_wmark_pages(zone), SWAP_CLUSTER_MAX);、
    	shrink_node
    		prepare_scan_count
    			mem_cgroup_lruvec
    				 sc->target_mem_cgroup = root_mem_cgroup;
    		shrink_node_memcgs //回收节点的memcg内存
    			for_mem_cgroup_iter	//便利memcg执行回收流程
    				shrink_lruvec	//回收memcg的LRU的内存
            			get_scan_count		//这个函数会计算文件页匿名页回收的页数
    				shrink_slab		//slab内存

get_scan_count
struct page_counter
    
```



```c
struct scan_control {
	unsigned long nr_to_reclaim;
	nodemask_t	*nodemask;
	struct mem_cgroup *target_mem_cgroup;
	unsigned long	anon_cost;
	unsigned long	file_cost;
#define DEACTIVATE_ANON 1
#define DEACTIVATE_FILE 2
	unsigned int may_deactivate:2;
	unsigned int force_deactivate:1;
	unsigned int skipped_deactivate:1;
	unsigned int may_writepage:1;
	unsigned int may_unmap:1;
	unsigned int may_swap:1;
	unsigned int proactive:1;
	unsigned int memcg_low_reclaim:1;
	unsigned int memcg_low_skipped:1;
	unsigned int hibernation_mode:1;
	unsigned int compaction_ready:1;
	unsigned int cache_trim_mode:1;
	unsigned int file_is_tiny:1;
	unsigned int no_demotion:1;
#ifdef CONFIG_LRU_GEN
	unsigned int memcgs_need_aging:1;
	unsigned long last_reclaimed;
#endif
	s8 order;
	s8 priority;
	s8 reclaim_idx;
	gfp_t gfp_mask;
	unsigned long nr_scanned;
	unsigned long nr_reclaimed;
	struct {
		unsigned int dirty;
		unsigned int unqueued_dirty;
		unsigned int congested;
		unsigned int writeback;
		unsigned int immediate;
		unsigned int file_taken;
		unsigned int taken;
	} nr;
	struct reclaim_state reclaim_state;
};
```

